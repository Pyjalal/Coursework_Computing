CHIP CPU {

    IN  inM[16],              // M value input (contents of RAM[A])
        instruction[16],      // Instruction for execution
        reset;                // Reset signal: 1 to restart the program, 0 to continue

    OUT outM[16],             // M value output (result from ALU)
        writeM,               // Write enable for M
        addressM[15],         // Address in data memory (for M)
        pc[15];               // Program counter for next instruction

    PARTS:
    
    // Decode A/C Instruction: 0 = A-instruction, 1 = C-instruction
    Not(in=instruction[15], out=isAInstruction);
    
    // Memory Write Enable for C-instructions (based on d3 bit in instruction)
    And(a=instruction[15], b=instruction[3], out=writeM);

    // Input multiplexer for A-register: uses instruction or ALU output
    Mux16(a=instruction, b=aluOut, sel=instruction[15], out=aRegisterInput);

    // Control load for A-register: A-instruction or destination to A in C-instruction
    Or(a=isAInstruction, b=instruction[5], out=loadA);

    // A-register to store address or data, outputting addressM
    ARegister(in=aRegisterInput, load=loadA, out=aRegisterOut, out[0..14]=addressM);

    // Mux for ALU input Y: selects between A-register and M (memory input)
    Mux16(a=aRegisterOut, b=inM, sel=instruction[12], out=aluInputY);

    // D Register - controlled by d2 in instruction for C-instruction
    And(a=instruction[15], b=instruction[4], out=loadD);
    DRegister(in=aluOut, load=loadD, out=dRegisterOut);

    // ALU processing using inputs from D register and selected Y input (A-register or M)
    ALU(x=dRegisterOut, y=aluInputY, 
        zx=instruction[11], nx=instruction[10],
        zy=instruction[9], ny=instruction[8],
        f=instruction[7], no=instruction[6],
        out=aluOut, out=outM, zr=zeroFlag, ng=negFlag);

    // Jump logic - using the 3 jump bits in instruction
    Or(a=negFlag, b=zeroFlag, out=negOrZero);
    Not(in=negFlag, out=notNeg);
    Not(in=zeroFlag, out=notZero);
    Not(in=negOrZero, out=notNegOrZero);

    Mux8Way(a=false,            // No jump (000)
            b=notNegOrZero,     // Jump if positive (001)
            c=zeroFlag,         // Jump if zero (010)
            d=notNeg,           // Jump if non-negative (011)
            e=negFlag,          // Jump if negative (100)
            f=notZero,          // Jump if non-zero (101)
            g=negOrZero,        // Jump if negative or zero (110)
            h=true,             // Unconditional jump (111)
            sel[0]=instruction[0], 
            sel[1]=instruction[1], 
            sel[2]=instruction[2], 
            out=jumpCondition);

    // Predict "not taken"
    // Modify the PC load logic to incorporate "not taken" prediction
    And(a=instruction[15], b=jumpCondition, out=actualJump);
    And(a=actualJump, b=true, out=loadPC); // Only load PC on actual jump

    // Program Counter (PC) - defaults to incrementing unless jump condition is met
    PC(in=aRegisterOut, load=loadPC, inc=true, reset=reset, out[0..14]=pc);
}

